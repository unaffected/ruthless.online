# Ruthless Style Guide

This document outlines the architectural principles, coding conventions, and best practices for the Ruthless codebase.

## Architecture Principles

### Separation of Concerns

The codebase is organized into three primary domains:

- **`game/`** - Shared game logic (ECS components, systems, actions)
  - Runs on both client and server
  - Contains pure game mechanics and business logic
  - Framework-agnostic, reusable code

- **`client/`** - Client-specific code (rendering, input, prediction)
  - Handles user input and visual presentation
  - Implements client-side prediction and interpolation
  - PixiJS rendering and DOM interactions

- **`server/`** - Server-authoritative code (validation, state management)
  - Acts as the source of truth for game state
  - Validates all player actions
  - Manages connections and synchronization

### Entity-Component-System (ECS)

The game uses a data-oriented ECS architecture powered by **bitecs**:

- **Entities** are numeric IDs representing game objects
- **Components** are plain data structures (typed arrays for performance)
- **Systems** contain logic that operates on entities with specific components
- Systems declare explicit dependencies and execute in a deterministic order
- This pattern enables cache-friendly data access and easy parallelization

### Dependency Injection

Systems explicitly declare their dependencies:

```typescript
export const system: System = {
  id: 'client:controller',
  dependencies: [network, input],
  install: async (game) => { /* ... */ },
  tick: async (game) => { /* ... */ }
}
```

Benefits:
- Clear dependency graph
- Predictable initialization order
- Easy testing and mocking
- No hidden coupling

### Event-Driven Communication

Systems communicate through a loosely-coupled event system:

- Use `game.emit(event, data)` to publish events
- Use `game.on(event, handler)` to subscribe to events
- Events are namespaced with colon notation (e.g., `'client:controller:input'`)
- Enables decoupling between systems while maintaining clear communication paths

### Client-Side Prediction & Server Reconciliation

For responsive multiplayer:

- **Client predicts** local player actions immediately
- **Server validates** and broadcasts authoritative state
- **Client reconciles** when predictions diverge from server
- Uses input history and rollback for smooth correction

## Naming Conventions

### snake_case for All Identifiers

Use snake_case for functions, variables, methods, and properties:

```typescript
// ✅ Good
function spawn_entity() { }
const movement_speed = 5.0
const player_data = { position_x: 0, position_y: 0 }

// ❌ Bad
function spawnEntity() { }
const movementSpeed = 5.0
const playerData = { positionX: 0, positionY: 0 }
```

### SCREAMING_SNAKE_CASE for Constants

Use SCREAMING_SNAKE_CASE for constants and enum-like values:

```typescript
// ✅ Good
export const PACKET = {
  SNAPSHOT: 0,
  SYNC: 1,
  UPDATE: 2,
} as const

export const MAX_PLAYERS = 64
```

### lowercase:colon for Namespaced Strings

Use colon-separated lowercase for system IDs and event names:

```typescript
// ✅ Good - System IDs
id: 'client:controller'
id: 'server:player'
id: 'action'

// ✅ Good - Event names
game.emit('client:controller:input', data)
game.on('server:player:connected', handler)
```

### Exception: External Libraries

Keep external library conventions unchanged:

```typescript
// ✅ Keep React conventions
const [state, setState] = useState(0)
useEffect(() => { }, [])

// ✅ Keep PixiJS conventions
stage.addChild(sprite)
graphics.removeChild(child)

// ✅ Keep bitecs conventions
addEntity(world)
hasComponent(world, entity, component)

// ✅ Keep Bun conventions
Bun.serve({ })
Bun.file(path)
```

## Code Organization

### One Concept Per File

Each file should have a single, clear responsibility:

- Export one primary concept (system, component, action, graphic)
- Use both named export and default export for flexibility
- Keep files focused and cohesive

```typescript
export const system: System = { /* ... */ }
export default system
```

### Path Aliases

Use `@/` for absolute imports instead of relative paths:

```typescript
// ✅ Good
import { Game } from '@/game'
import network from '@/client/system/network'

// ❌ Avoid
import { Game } from '../../../game'
import network from './network'
```

### Type Safety via Module Augmentation

Extend core types declaratively rather than using wrapper classes:

```typescript
// ✅ Good - Module augmentation
declare module '@/game' {
  interface Game {
    input: InputState
  }
}

// Then access directly
game.input.state

// ❌ Avoid - Wrapper classes
class GameWrapper {
  constructor(public game: Game) {}
  get input() { return this.inputState }
}
```

## TypeScript Usage

### Strict Mode

The codebase uses TypeScript strict mode:

- All types must be explicit (no implicit `any`)
- Null and undefined are handled explicitly
- Use `noUncheckedIndexedAccess` for safer array/object access
- Leverage the type system for correctness guarantees

### Type-First Development

Define interfaces before implementation:

```typescript
// Define the contract first
export type Action<K extends ACTION = ACTION> = {
  id: K
  execute: (game: Game, entity: number, params: Actions[K]) => void
}

// Then implement
export const action: Action<'move'> = {
  id: 'move',
  execute: (game, entity, params) => { /* ... */ }
}
```

### Module Augmentation Pattern

Extend global types at the file level where functionality is added:

```typescript
// At the top of the file that adds functionality
declare module '@/game' {
  interface Game {
    prediction: PredictionState
  }
}

// Then implement in the same file
export const system: System = {
  install: async (game) => {
    game.prediction = { /* ... */ }
  }
}
```

### Guard Clauses

Use early returns to reduce nesting:

```typescript
// ✅ Good
function update(entity: number) {
  const player = game.get(entity, 'player')
  if (!player) return
  
  player.position_x += 1
}

// ❌ Avoid deep nesting
function update(entity: number) {
  const player = game.get(entity, 'player')
  if (player) {
    player.position_x += 1
  }
}
```

### Optional Chaining with Nullish Coalescing

Use `?.` and `??` for safe property access with defaults:

```typescript
const color = options?.color ?? 0xFF0000
const value = config?.settings?.value ?? default_value
```

## Best Practices

### Performance-First

Optimize for performance in hot paths:

- **Mutate objects in place** - Avoid unnecessary allocations
- **Direct property updates** - Skip spread operators and object copying
- **Minimize garbage collection** - Reuse objects when possible
- **Cache-friendly data access** - Leverage ECS data locality

```typescript
// ✅ Good - Direct mutation
player.position_x += velocity_x
player.position_y += velocity_y

// ❌ Avoid - Creates new objects
player = { ...player, position_x: player.position_x + velocity_x }
```

### Minimize Object Duplication

Avoid creating unnecessary copies:

```typescript
// ✅ Good - Direct access and mutation
const player = game.get(entity, 'player')
if (player) {
  player.health_current -= damage
  game.set(entity, 'player', player)
}

// ❌ Avoid - Unnecessary spreading
const player = game.get(entity, 'player')
if (player) {
  game.set(entity, 'player', { 
    ...player, 
    health_current: player.health_current - damage 
  })
}
```

### Namespaced Logging

Include system context in all console output:

```typescript
console.debug('[client:controller] system initialized')
console.warn('[client:prediction] large divergence:', delta)
console.error('[server:network] connection failed:', error)
```

### Explicit Over Implicit

Write clear, obvious code rather than clever abstractions:

- Prefer explicit types over inference when it aids readability
- Use descriptive variable names
- Favor clarity over brevity
- Comment complex algorithms, not obvious code

### Cache-Friendly Data

Leverage ECS data locality in performance-critical loops:

- Iterate over component arrays directly when possible
- Use `game.query()` to batch process entities
- Keep hot data in contiguous memory (typed arrays)
- Avoid pointer chasing and scattered memory access

```typescript
// ✅ Good - Batch processing with query
const players = game.query([game.components.player])
for (const entity of players) {
  const player = game.get(entity, 'player')
  // Process player...
}
```

## Summary

The Ruthless codebase prioritizes:

1. **Clear separation** of client, server, and shared concerns
2. **Performance** through data-oriented design and minimal allocations
3. **Type safety** via strict TypeScript and module augmentation
4. **Maintainability** through consistent naming and explicit dependencies
5. **Scalability** via event-driven architecture and ECS patterns

Follow these guidelines to maintain consistency and quality across the codebase.
